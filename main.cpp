#include <iostream>
#include <sstream>
#include <string>
#include <cstdlib>
#include <stack>
#include <memory>

#include <cppast/libclang_parser.hpp>
#include <cppast/visitor.hpp>
#include <cppast/cpp_member_variable.hpp>
#include <cppast/cpp_member_function.hpp>
#include <set>

#include "generators.h"

int main(int argc, char **argv) {
  if (argc != 2) {
    std::cerr << "Usage: " << argv[0] << " DIRECTORY" << std::endl;
    std::cerr << std::endl;
    std::cerr << "Will read compile_commands.json file from DIRECTORY and use it to generate code." << std::endl;
    return EXIT_FAILURE;
  }

  cppast::libclang_compilation_database database{argv[1]};

  cppast::cpp_entity_index index{};
  cppast::simple_file_parser<cppast::libclang_parser> parser{type_safe::ref(index)};

  try {
    cppast::parse_database(parser, database);
  } catch (cppast::libclang_error &ex) {
    std::cerr << "fatal libclang error: " << ex.what() << std::endl;
    return EXIT_FAILURE;
  }

  if (parser.error()) {
    return EXIT_FAILURE;
  }

  std::ostringstream header, body, footer;

  header << "/***\n"
         << " *\n"
         << " * This file was generated by ccenerate.\n"
         << " * DO NOT MODIFY MANUALLY\n"
         << " *\n"
         << "***/\n"
         << "\n";

  std::set<std::string> includes;

  for (auto &file : parser.files()) {
    std::stack<generator_list> generator_stack;

    cppast::visit(file, [&](const cppast::cpp_entity &e, cppast::visitor_info vi) -> bool {
      if (vi.event == cppast::visitor_info::container_entity_exit) {
        generator_stack.top().write(body);
        generator_stack.pop();
        return true;
      }

      if (!generator_stack.empty()) {
        generator_list &list = generator_stack.top();

        if (e.kind() == cppast::cpp_entity_kind::member_variable_t) {
          list.add_member_variable(static_cast<const cppast::cpp_member_variable &>(e));
        }
      }

      if (vi.event == cppast::visitor_info::container_entity_enter) {
        generator_list list{index};

        if (e.kind() == cppast::cpp_entity_kind::class_t) {
          const cppast::cpp_class &cls = static_cast<const cppast::cpp_class &>(e);
          if (cls.is_definition() && cppast::has_attribute(cls, "json::generate")) {
            list.emplace<json_generator>(cls);
            includes.insert("json.hpp");
          }
        }

        generator_stack.push(std::move(list));
      }

      return true;
    });
  }

  if (!includes.empty()) {
    for (const std::string &include : includes)
      header << "#include <" << include << ">\n";
    header << "\n";
  }

  std::cout << header.str() << body.str() << footer.str();
}
